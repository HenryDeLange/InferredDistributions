package mywild.inferreddistributions;

import java.awt.Cursor;
import java.awt.EventQueue;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.UIManager;
import javax.swing.UnsupportedLookAndFeelException;
import javax.swing.filechooser.FileFilter;

public class DataGeneratorAppForINat extends JFrame {
    private String dataFolder = Paths.get(System.getProperty("user.home"), 
            "InferredDistributions", "RawData", "iNaturalistData").toAbsolutePath().toString();
    private String baselineFile = Paths.get(System.getProperty("user.home"), 
            "InferredDistributions", "RawData", "iNaturalistData").toAbsolutePath().toString();

    public DataGeneratorAppForINat() {
        initComponents();
    }
    
    public static void main(String args[]) {
        // Set native Look and Feel
        try {
            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        }
        catch (ClassNotFoundException | InstantiationException | IllegalAccessException | UnsupportedLookAndFeelException ex) {
            Logger.getLogger(DataGeneratorAppForINat.class.getName()).log(Level.SEVERE, null, ex);
        }
        // Launch the application
        EventQueue.invokeLater(new Runnable() {
            public void run() {
                DataGeneratorAppForINat app = new DataGeneratorAppForINat();
                app.setLocationRelativeTo(null);
                app.setVisible(true);
            }
        });
    }

    /**
     * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The content of this method is always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jPanel1 = new javax.swing.JPanel();
        jLabel6 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        spnLonTL = new javax.swing.JSpinner();
        spnLonBR = new javax.swing.JSpinner();
        spnLatTL = new javax.swing.JSpinner();
        spnLatBR = new javax.swing.JSpinner();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        jPanel2 = new javax.swing.JPanel();
        jLabel7 = new javax.swing.JLabel();
        txtDataFolderPath = new javax.swing.JTextField();
        btnDataFolderBrowse = new javax.swing.JButton();
        jPanel3 = new javax.swing.JPanel();
        jLabel8 = new javax.swing.JLabel();
        spnGridSize = new javax.swing.JSpinner();
        jLabel10 = new javax.swing.JLabel();
        jPanel4 = new javax.swing.JPanel();
        jLabel9 = new javax.swing.JLabel();
        chkReplaceFiles = new javax.swing.JCheckBox();
        jLabel11 = new javax.swing.JLabel();
        txtLatName = new javax.swing.JTextField();
        jLabel12 = new javax.swing.JLabel();
        txtLonName = new javax.swing.JTextField();
        jLabel13 = new javax.swing.JLabel();
        chkCSVHasHeader = new javax.swing.JCheckBox();
        chkUseINatFields = new javax.swing.JCheckBox();
        jPanel5 = new javax.swing.JPanel();
        jLabel15 = new javax.swing.JLabel();
        txtBaselineFilePath = new javax.swing.JTextField();
        btnBaselineFileBrowse = new javax.swing.JButton();
        btnGenerateAbsenceDatasets = new javax.swing.JButton();
        jPanel6 = new javax.swing.JPanel();
        jLabel16 = new javax.swing.JLabel();
        spnNearbyRadius = new javax.swing.JSpinner();
        jLabel17 = new javax.swing.JLabel();
        btnGeneratePresenceDatasets = new javax.swing.JButton();
        jSeparator1 = new javax.swing.JSeparator();
        jLabel18 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Dataset Generator for iNaturalist");
        setMinimumSize(new java.awt.Dimension(880, 860));
        setPreferredSize(new java.awt.Dimension(880, 860));

        jLabel1.setFont(jLabel1.getFont().deriveFont(jLabel1.getFont().getStyle() | java.awt.Font.BOLD, jLabel1.getFont().getSize()+15));
        jLabel1.setText("Dataset Generator for iNaturalist Data");

        jLabel6.setFont(jLabel6.getFont().deriveFont(jLabel6.getFont().getStyle() | java.awt.Font.BOLD, jLabel6.getFont().getSize()+2));
        jLabel6.setText("Bottom-Right Longitude:");

        jLabel2.setFont(jLabel2.getFont().deriveFont(jLabel2.getFont().getStyle() | java.awt.Font.BOLD, jLabel2.getFont().getSize()+2));
        jLabel2.setText("Top-Left Latitude:");

        spnLonTL.setFont(spnLonTL.getFont().deriveFont(spnLonTL.getFont().getSize()+1f));
        spnLonTL.setModel(new javax.swing.SpinnerNumberModel(10.0d, -180.0d, 180.0d, 1.0d));
        spnLonTL.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));

        spnLonBR.setFont(spnLonBR.getFont().deriveFont(spnLonBR.getFont().getSize()+1f));
        spnLonBR.setModel(new javax.swing.SpinnerNumberModel(40.0d, -180.0d, 180.0d, 1.0d));
        spnLonBR.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));

        spnLatTL.setFont(spnLatTL.getFont().deriveFont(spnLatTL.getFont().getSize()+1f));
        spnLatTL.setModel(new javax.swing.SpinnerNumberModel(-16.0d, -90.0d, 90.0d, 1.0d));
        spnLatTL.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));

        spnLatBR.setFont(spnLatBR.getFont().deriveFont(spnLatBR.getFont().getSize()+1f));
        spnLatBR.setModel(new javax.swing.SpinnerNumberModel(-35.0d, -90.0d, 90.0d, 1.0d));
        spnLatBR.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));

        jLabel3.setFont(jLabel3.getFont().deriveFont(jLabel3.getFont().getStyle() | java.awt.Font.BOLD, jLabel3.getFont().getSize()+2));
        jLabel3.setText("Top-Left Longitude:");

        jLabel4.setFont(jLabel4.getFont().deriveFont(jLabel4.getFont().getStyle() | java.awt.Font.BOLD, jLabel4.getFont().getSize()+6));
        jLabel4.setText("Bounding Box");

        jLabel5.setFont(jLabel5.getFont().deriveFont(jLabel5.getFont().getStyle() | java.awt.Font.BOLD, jLabel5.getFont().getSize()+2));
        jLabel5.setText("Bottom-Right Latitude:");

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(5, 5, 5)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel4)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel2)
                            .addComponent(jLabel3))
                        .addGap(10, 10, 10)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(spnLatTL)
                            .addComponent(spnLonTL))
                        .addGap(50, 50, 50)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel5)
                            .addComponent(jLabel6))
                        .addGap(10, 10, 10)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(spnLatBR)
                            .addComponent(spnLonBR))))
                .addGap(5, 5, 5))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(5, 5, 5)
                .addComponent(jLabel4)
                .addGap(5, 5, 5)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                            .addComponent(spnLatTL)
                            .addComponent(jLabel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addGap(5, 5, 5)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(spnLonTL)
                            .addComponent(jLabel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                            .addComponent(spnLatBR)
                            .addComponent(jLabel5, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addGap(5, 5, 5)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(spnLonBR)
                            .addComponent(jLabel6, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
                .addGap(5, 5, 5))
        );

        jLabel7.setFont(jLabel7.getFont().deriveFont(jLabel7.getFont().getStyle() | java.awt.Font.BOLD, jLabel7.getFont().getSize()+6));
        jLabel7.setText("Data Folder");

        txtDataFolderPath.setFont(txtDataFolderPath.getFont().deriveFont(txtDataFolderPath.getFont().getSize()+2f));
        txtDataFolderPath.setHorizontalAlignment(javax.swing.JTextField.CENTER);
        txtDataFolderPath.setText(dataFolder);
        txtDataFolderPath.setEnabled(false);

        btnDataFolderBrowse.setFont(btnDataFolderBrowse.getFont().deriveFont(btnDataFolderBrowse.getFont().getSize()+2f));
        btnDataFolderBrowse.setText("Browse");
        btnDataFolderBrowse.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        btnDataFolderBrowse.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnDataFolderBrowseActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addGap(5, 5, 5)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(jLabel7)
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(txtDataFolderPath)
                        .addGap(5, 5, 5)
                        .addComponent(btnDataFolderBrowse, javax.swing.GroupLayout.PREFERRED_SIZE, 107, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addGap(5, 5, 5))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addGap(5, 5, 5)
                .addComponent(jLabel7)
                .addGap(5, 5, 5)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(txtDataFolderPath, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(btnDataFolderBrowse))
                .addGap(5, 5, 5))
        );

        jLabel8.setFont(jLabel8.getFont().deriveFont(jLabel8.getFont().getStyle() | java.awt.Font.BOLD, jLabel8.getFont().getSize()+6));
        jLabel8.setText("Grid Size");

        spnGridSize.setFont(spnGridSize.getFont().deriveFont(spnGridSize.getFont().getSize()+1f));
        spnGridSize.setModel(new javax.swing.SpinnerNumberModel(0.25d, 0.01d, 1.0d, 0.1d));
        spnGridSize.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));

        jLabel10.setFont(jLabel10.getFont().deriveFont(jLabel10.getFont().getStyle() | java.awt.Font.BOLD, jLabel10.getFont().getSize()+2));
        jLabel10.setText("Degree Fraction:");

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addGap(5, 5, 5)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addComponent(jLabel10)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(spnGridSize, javax.swing.GroupLayout.DEFAULT_SIZE, 250, Short.MAX_VALUE)
                        .addGap(487, 487, 487))
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addComponent(jLabel8)
                        .addGap(5, 5, 5))))
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addGap(5, 5, 5)
                .addComponent(jLabel8)
                .addGap(5, 5, 5)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(spnGridSize, javax.swing.GroupLayout.DEFAULT_SIZE, 23, Short.MAX_VALUE)
                    .addComponent(jLabel10, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(5, 5, 5))
        );

        jLabel9.setFont(jLabel9.getFont().deriveFont(jLabel9.getFont().getStyle() | java.awt.Font.BOLD, jLabel9.getFont().getSize()+6));
        jLabel9.setText("Options");

        chkReplaceFiles.setFont(chkReplaceFiles.getFont().deriveFont(chkReplaceFiles.getFont().getSize()+1f));
        chkReplaceFiles.setSelected(true);
        chkReplaceFiles.setText("Replace exisitng files");
        chkReplaceFiles.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));

        jLabel11.setFont(jLabel11.getFont().deriveFont(jLabel11.getFont().getSize()+1f));
        jLabel11.setText("Latitude Column:");

        txtLatName.setFont(txtLatName.getFont().deriveFont(txtLatName.getFont().getSize()+1f));
        txtLatName.setHorizontalAlignment(javax.swing.JTextField.CENTER);
        txtLatName.setText("latitude");

        jLabel12.setFont(jLabel12.getFont().deriveFont(jLabel12.getFont().getSize()+1f));
        jLabel12.setText("Longitude Column:");

        txtLonName.setFont(txtLonName.getFont().deriveFont(txtLonName.getFont().getSize()+1f));
        txtLonName.setHorizontalAlignment(javax.swing.JTextField.CENTER);
        txtLonName.setText("longitude");

        jLabel13.setFont(jLabel13.getFont().deriveFont(jLabel13.getFont().getStyle() | java.awt.Font.BOLD, jLabel13.getFont().getSize()+1));
        jLabel13.setText("Settings:");

        chkCSVHasHeader.setFont(chkCSVHasHeader.getFont().deriveFont(chkCSVHasHeader.getFont().getSize()+1f));
        chkCSVHasHeader.setSelected(true);
        chkCSVHasHeader.setText("CSV has header");
        chkCSVHasHeader.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        chkCSVHasHeader.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                chkCSVHasHeaderActionPerformed(evt);
            }
        });

        chkUseINatFields.setFont(chkUseINatFields.getFont().deriveFont(chkUseINatFields.getFont().getSize()+1f));
        chkUseINatFields.setSelected(true);
        chkUseINatFields.setText("Use iNaturalist data quality fields");
        chkUseINatFields.setToolTipText("<html>\nFile must include the header. <br>\nSupported fields: out_of_range, quality_grade, positional_accuracy, captive_cultivated, coordinates_obscured.\n</html>");
        chkUseINatFields.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));

        javax.swing.GroupLayout jPanel4Layout = new javax.swing.GroupLayout(jPanel4);
        jPanel4.setLayout(jPanel4Layout);
        jPanel4Layout.setHorizontalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel4Layout.createSequentialGroup()
                .addGap(5, 5, 5)
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel4Layout.createSequentialGroup()
                        .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanel4Layout.createSequentialGroup()
                                .addComponent(jLabel11)
                                .addGap(10, 10, 10)
                                .addComponent(txtLatName)
                                .addGap(25, 25, 25)
                                .addComponent(jLabel12)
                                .addGap(10, 10, 10)
                                .addComponent(txtLonName))
                            .addGroup(jPanel4Layout.createSequentialGroup()
                                .addComponent(jLabel9)
                                .addGap(0, 0, Short.MAX_VALUE)))
                        .addGap(5, 5, 5))
                    .addGroup(jPanel4Layout.createSequentialGroup()
                        .addComponent(jLabel13)
                        .addGap(18, 18, 18)
                        .addComponent(chkReplaceFiles)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 33, Short.MAX_VALUE)
                        .addComponent(chkCSVHasHeader)
                        .addGap(32, 32, 32)
                        .addComponent(chkUseINatFields)
                        .addGap(269, 269, 269))))
        );
        jPanel4Layout.setVerticalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel4Layout.createSequentialGroup()
                .addGap(5, 5, 5)
                .addComponent(jLabel9)
                .addGap(5, 5, 5)
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(chkReplaceFiles)
                    .addComponent(jLabel13)
                    .addComponent(chkCSVHasHeader)
                    .addComponent(chkUseINatFields))
                .addGap(4, 4, 4)
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel11)
                    .addComponent(txtLatName, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel12)
                    .addComponent(txtLonName, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(5, 5, 5))
        );

        jLabel15.setFont(jLabel15.getFont().deriveFont(jLabel15.getFont().getStyle() | java.awt.Font.BOLD, jLabel15.getFont().getSize()+6));
        jLabel15.setText("Baseline Presence File");

        txtBaselineFilePath.setFont(txtBaselineFilePath.getFont().deriveFont(txtBaselineFilePath.getFont().getSize()+2f));
        txtBaselineFilePath.setHorizontalAlignment(javax.swing.JTextField.CENTER);
        txtBaselineFilePath.setText(dataFolder);
        txtBaselineFilePath.setEnabled(false);

        btnBaselineFileBrowse.setFont(btnBaselineFileBrowse.getFont().deriveFont(btnBaselineFileBrowse.getFont().getSize()+2f));
        btnBaselineFileBrowse.setText("Browse");
        btnBaselineFileBrowse.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        btnBaselineFileBrowse.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnBaselineFileBrowseActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel5Layout = new javax.swing.GroupLayout(jPanel5);
        jPanel5.setLayout(jPanel5Layout);
        jPanel5Layout.setHorizontalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel5Layout.createSequentialGroup()
                .addGap(5, 5, 5)
                .addGroup(jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel5Layout.createSequentialGroup()
                        .addComponent(jLabel15)
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addGroup(jPanel5Layout.createSequentialGroup()
                        .addComponent(txtBaselineFilePath)
                        .addGap(5, 5, 5)
                        .addComponent(btnBaselineFileBrowse, javax.swing.GroupLayout.PREFERRED_SIZE, 107, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addGap(5, 5, 5))
        );
        jPanel5Layout.setVerticalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel5Layout.createSequentialGroup()
                .addGap(5, 5, 5)
                .addComponent(jLabel15)
                .addGap(5, 5, 5)
                .addGroup(jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(txtBaselineFilePath, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(btnBaselineFileBrowse))
                .addGap(5, 5, 5))
        );

        btnGenerateAbsenceDatasets.setFont(btnGenerateAbsenceDatasets.getFont().deriveFont(btnGenerateAbsenceDatasets.getFont().getStyle() | java.awt.Font.BOLD, btnGenerateAbsenceDatasets.getFont().getSize()+13));
        btnGenerateAbsenceDatasets.setText("Generate Absence Datasets");
        btnGenerateAbsenceDatasets.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        btnGenerateAbsenceDatasets.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnGenerateAbsenceDatasetsActionPerformed(evt);
            }
        });

        jLabel16.setFont(jLabel16.getFont().deriveFont(jLabel16.getFont().getStyle() | java.awt.Font.BOLD, jLabel16.getFont().getSize()+6));
        jLabel16.setText("Check Nearby");

        spnNearbyRadius.setFont(spnNearbyRadius.getFont().deriveFont(spnNearbyRadius.getFont().getSize()+1f));
        spnNearbyRadius.setModel(new javax.swing.SpinnerNumberModel(3, 1, 20, 1));
        spnNearbyRadius.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        spnNearbyRadius.setPreferredSize(new java.awt.Dimension(150, 22));

        jLabel17.setFont(jLabel17.getFont().deriveFont(jLabel17.getFont().getStyle() | java.awt.Font.BOLD, jLabel17.getFont().getSize()+2));
        jLabel17.setText("Radius for calculating absence:");

        javax.swing.GroupLayout jPanel6Layout = new javax.swing.GroupLayout(jPanel6);
        jPanel6.setLayout(jPanel6Layout);
        jPanel6Layout.setHorizontalGroup(
            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel6Layout.createSequentialGroup()
                .addGap(5, 5, 5)
                .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel6Layout.createSequentialGroup()
                        .addComponent(jLabel17)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(spnNearbyRadius, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(jLabel16))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanel6Layout.setVerticalGroup(
            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel6Layout.createSequentialGroup()
                .addGap(5, 5, 5)
                .addComponent(jLabel16)
                .addGap(5, 5, 5)
                .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(spnNearbyRadius, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel17, javax.swing.GroupLayout.DEFAULT_SIZE, 23, Short.MAX_VALUE))
                .addGap(5, 5, 5))
        );

        btnGeneratePresenceDatasets.setFont(btnGeneratePresenceDatasets.getFont().deriveFont(btnGeneratePresenceDatasets.getFont().getStyle() | java.awt.Font.BOLD, btnGeneratePresenceDatasets.getFont().getSize()+13));
        btnGeneratePresenceDatasets.setText("Generate Presence Datasets");
        btnGeneratePresenceDatasets.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        btnGeneratePresenceDatasets.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnGeneratePresenceDatasetsActionPerformed(evt);
            }
        });

        jLabel18.setFont(jLabel18.getFont().deriveFont(jLabel18.getFont().getSize()+1f));
        jLabel18.setText("<html>\nManually download the desired data from the iNaturalist website as CSV files. <br>\nThen use this program to generate the datasets to be used to train the neural networks.<br>\n<br>\nThe following fields are recommended for the iNaturalist data export:<br>\n<i>id, out_of_range, quality_grade, captive_cultivated, latitude, longitude, positional_accuracy, coordinates_obscured, scientific_name, iconic_taxon_name</i>\n</html>");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jLabel1)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addGroup(layout.createSequentialGroup()
                .addGap(10, 10, 10)
                .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGap(10, 10, 10))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel4, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(btnGenerateAbsenceDatasets, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(btnGeneratePresenceDatasets, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jSeparator1)
                .addContainerGap())
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel6, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel5, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel18, javax.swing.GroupLayout.DEFAULT_SIZE, 860, Short.MAX_VALUE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(10, 10, 10)
                .addComponent(jLabel1)
                .addGap(10, 10, 10)
                .addComponent(jLabel18, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(10, 10, 10)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(10, 10, 10)
                .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(10, 10, 10)
                .addComponent(jPanel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGap(10, 10, 10)
                .addComponent(jPanel4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(20, 20, 20)
                .addComponent(btnGeneratePresenceDatasets, javax.swing.GroupLayout.PREFERRED_SIZE, 80, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 15, Short.MAX_VALUE)
                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 5, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 10, Short.MAX_VALUE)
                .addComponent(jPanel6, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGap(10, 10, 10)
                .addComponent(jPanel5, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(10, 10, 10)
                .addComponent(btnGenerateAbsenceDatasets, javax.swing.GroupLayout.PREFERRED_SIZE, 80, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void btnDataFolderBrowseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnDataFolderBrowseActionPerformed
        JFileChooser fileChooser = new JFileChooser(dataFolder);
        fileChooser.setMultiSelectionEnabled(false);
        fileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
        fileChooser.setDialogType(JFileChooser.OPEN_DIALOG);
        int result = fileChooser.showOpenDialog(this);
        if ((result != JFileChooser.ERROR_OPTION) && (result == JFileChooser.APPROVE_OPTION)) {
            dataFolder = fileChooser.getSelectedFile().toPath().toAbsolutePath().toString();
            txtDataFolderPath.setText(dataFolder);
        }
    }//GEN-LAST:event_btnDataFolderBrowseActionPerformed

    private void chkCSVHasHeaderActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_chkCSVHasHeaderActionPerformed
        if (chkCSVHasHeader.isSelected()) {
            txtLatName.setText("latitude");
            txtLonName.setText("longitude");
        }
        else {
            txtLatName.setText("1");
            txtLonName.setText("2");
        }
    }//GEN-LAST:event_chkCSVHasHeaderActionPerformed

    private void btnBaselineFileBrowseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnBaselineFileBrowseActionPerformed
        JFileChooser fileChooser = new JFileChooser(baselineFile);
        fileChooser.setMultiSelectionEnabled(false);
        fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
        fileChooser.setAcceptAllFileFilterUsed(false);
        fileChooser.setFileFilter(new FileFilter() {
            @Override
            public boolean accept(File file) {
                return file.isDirectory() || file.getName().toLowerCase().endsWith(".idi");
            }

            @Override
            public String getDescription() {
                return "IDI";
            }
        });
        fileChooser.setDialogType(JFileChooser.OPEN_DIALOG);
        int result = fileChooser.showOpenDialog(this);
        if ((result != JFileChooser.ERROR_OPTION) && (result == JFileChooser.APPROVE_OPTION)) {
            baselineFile = fileChooser.getSelectedFile().toPath().toAbsolutePath().toString();
            txtBaselineFilePath.setText(baselineFile);
        }
    }//GEN-LAST:event_btnBaselineFileBrowseActionPerformed

    private void btnGenerateAbsenceDatasetsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnGenerateAbsenceDatasetsActionPerformed
        getGlassPane().setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
        getGlassPane().setVisible(true);
        if (Files.exists(Paths.get(baselineFile)) && Files.isRegularFile(Paths.get(baselineFile))) {
            try {
                Files.walkFileTree(Paths.get(dataFolder), new SimpleFileVisitor<Path>() {
                    @Override
                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                        if (file.getFileName().toString().toLowerCase().endsWith(".csv")) {
                            processAbsenceCSV(file);
                        }
                        return FileVisitResult.CONTINUE;
                    }
                });
                JOptionPane.showMessageDialog(this, "The absence datasets have been generated.", "FINISHED Absence Datasets", 
                        JOptionPane.INFORMATION_MESSAGE);
            }
            catch (Exception ex) {
                Logger.getLogger(DataGeneratorAppForINat.class.getName()).log(Level.SEVERE, null, ex);
                JOptionPane.showMessageDialog(this, "The absence datasets have NOT been generated.", "ERROR Absence Datasets", 
                        JOptionPane.ERROR_MESSAGE);
            }
        }
        else {
            JOptionPane.showMessageDialog(this, "Please specify the baseline file to use.", "No Baseline File!", 
                    JOptionPane.ERROR_MESSAGE);
        }
        getGlassPane().setVisible(false);
        getGlassPane().setCursor(Cursor.getDefaultCursor());
    }//GEN-LAST:event_btnGenerateAbsenceDatasetsActionPerformed

    private void btnGeneratePresenceDatasetsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnGeneratePresenceDatasetsActionPerformed
        getGlassPane().setVisible(true);
        getGlassPane().setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
        try {
            Files.walkFileTree(Paths.get(dataFolder), new SimpleFileVisitor<Path>() {
                @Override
                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                    if (file.getFileName().toString().toLowerCase().endsWith(".csv")) {
                        processPresenceCSV(file);
                    }
                    return FileVisitResult.CONTINUE;
                }
            });
            JOptionPane.showMessageDialog(this, "The presence datasets have been generated.", "FINISHED Presence Datasets", 
                    JOptionPane.INFORMATION_MESSAGE);
        }
        catch (Exception ex) {
            Logger.getLogger(DataGeneratorAppForINat.class.getName()).log(Level.SEVERE, null, ex);
            JOptionPane.showMessageDialog(this, "The presence datasets have NOT been generated.", "ERROR Presence Datasets", 
                    JOptionPane.ERROR_MESSAGE);
        }
        getGlassPane().setCursor(Cursor.getDefaultCursor());
        getGlassPane().setVisible(false);
    }//GEN-LAST:event_btnGeneratePresenceDatasetsActionPerformed

    private void processPresenceCSV(Path file) throws IOException {
        Logger.getLogger(DataGeneratorAppForINat.class.getName()).log(Level.INFO, "PRESENCE File: {0}", file.toString());
        // Get the presence data
        Map<String, MapCounter> mapGridCounts = new HashMap<>();
        populatePresenceMapCount(file, mapGridCounts);
        // Write the dataset file
        String filename = file.getFileName().toString();
        Path datasetFile = file.getParent().resolve(filename.substring(0, filename.length() - 4) + "_presence.idi");
        writeDataset(mapGridCounts, datasetFile);
    }

    private void populatePresenceMapCount(Path file, Map<String, MapCounter> mapGridCounts) throws IOException {
        final double GRID_SIZE = (double) spnGridSize.getValue();
        try (BufferedReader reader = new BufferedReader(new FileReader(file.toFile()))) {
            final String SEPARATOR_CHAR = ",";
            int latIndex = -1;
            int lonIndex = -1;
            int outOfRangeIndex = -1;
            int qualityGradeIndex = -1;
            int positionalAccuracyIndex = -1;
            int captiveCultivatedIndex = -1;
            int coordinatesObscuredIndex = -1;
            if (!chkCSVHasHeader.isSelected()) {
                try {
                    latIndex = Integer.parseInt(txtLatName.getText());
                    lonIndex = Integer.parseInt(txtLonName.getText());
                }
                catch (NumberFormatException ex) {
                    JOptionPane.showMessageDialog(this, "Please provide valid column numbers.", "ERROR Not A Number", 
                            JOptionPane.ERROR_MESSAGE);
                    return;
                }
            }
            int rowNum = 0;
            String line = null;
            while ((line = reader.readLine()) != null) {
                rowNum++;
                String[] dataRow = line.split(SEPARATOR_CHAR);
                if (rowNum == 1 && chkCSVHasHeader.isSelected()) {
                    // Process the header
                    for (int t = 0; t < dataRow.length; t++) {
                        if (dataRow[t].equalsIgnoreCase(txtLatName.getText())) {
                            latIndex = t;
                        }
                        else
                        if (dataRow[t].equalsIgnoreCase(txtLonName.getText())) {
                            lonIndex = t;
                        }
                        else
                        if (dataRow[t].equalsIgnoreCase("out_of_range")) {
                            outOfRangeIndex = t;
                        }
                        else
                        if (dataRow[t].equalsIgnoreCase("quality_grade")) {
                            qualityGradeIndex = t;
                        }
                        else
                        if (dataRow[t].equalsIgnoreCase("positional_accuracy")) {
                            positionalAccuracyIndex = t;
                        }
                        else
                        if (dataRow[t].equalsIgnoreCase("captive_cultivated")) {
                            captiveCultivatedIndex = t;
                        }
                        else
                        if (dataRow[t].equalsIgnoreCase("coordinates_obscured")) {
                            coordinatesObscuredIndex = t;
                        }
                    }
                    continue;
                }
                // Do validations
                if (chkCSVHasHeader.isSelected() && chkUseINatFields.isSelected()) {
                    if (outOfRangeIndex >= 0 && dataRow[outOfRangeIndex].equalsIgnoreCase("true")) {
                        Logger.getLogger(DataGeneratorAppForINat.class.getName()).log(Level.INFO, "Skipped: Observation Out of Range");
                        continue;
                    }
                    if (qualityGradeIndex >= 0 && !dataRow[qualityGradeIndex].equalsIgnoreCase("research")) {
                        Logger.getLogger(DataGeneratorAppForINat.class.getName()).log(Level.INFO, "Skipped: Not Research Grade");
                        continue;
                    }
                    if (positionalAccuracyIndex >= 0) {
                        String accuracyString = dataRow[positionalAccuracyIndex];
                        if (!accuracyString.isEmpty()) {
                            try {
                                int accuracy = Integer.parseInt(accuracyString);
                                if (accuracy > 50000) {
                                    Logger.getLogger(DataGeneratorAppForINat.class.getName()).log(Level.INFO, "Skipped: Accuracy > 50000");
                                    continue;
                                }
                            }
                            catch (NumberFormatException ex) {
                                Logger.getLogger(DataGeneratorAppForINat.class.getName()).log(Level.WARNING, null, ex);
                            }
                        }
                    }
                    if (captiveCultivatedIndex >= 0 && dataRow[captiveCultivatedIndex].equalsIgnoreCase("true")) {
                        Logger.getLogger(DataGeneratorAppForINat.class.getName()).log(Level.INFO, "Skipped: Captive");
                        continue;
                    }
                    if (coordinatesObscuredIndex >= 0 && dataRow[coordinatesObscuredIndex].equalsIgnoreCase("true")) {
                        Logger.getLogger(DataGeneratorAppForINat.class.getName()).log(Level.INFO, "Skipped: Obscured");
                        continue;
                    }
                }
                // Process the data row
                String key = buildGridKey(convertToGrid(dataRow[latIndex], GRID_SIZE), convertToGrid(dataRow[lonIndex], GRID_SIZE));
                MapCounter counter = mapGridCounts.get(key);
                if (counter == null) {
                    counter = new MapCounter();
                    mapGridCounts.put(key, counter);
                }
                counter.count++;
            }
            // Closing just to be paranoid (should be handled by the try-with-resources statement already)
            reader.close();
        }
    }
    
    private void processAbsenceCSV(Path file) throws IOException {
        Logger.getLogger(DataGeneratorAppForINat.class.getName()).log(Level.INFO, "ABSENCE File: {0}", file.toString());
        String filename = file.getFileName().toString();
        // Read all presence data
        Path presenceFile = file.getParent().resolve(filename.substring(0, filename.length() - 4) + "_presence.idi");
        List<List<Double>> lstPresenceValues = readDatasetFile(presenceFile);
        // Calculate the nearby presence
        double maxNearby = 0.0;
        int radius = (int) spnNearbyRadius.getValue();
        List<List<Double>> lstNearbyValues = new ArrayList<>(lstPresenceValues.size());
        for (int r = 0; r < lstPresenceValues.size(); r++) {
            List<Double> lstPresenceRow = lstPresenceValues.get(r);
            List<Double> lstNearbyRow = new ArrayList<>(lstPresenceRow.size());
            for (int c = 0; c < lstPresenceRow.size(); c++) {
                double nearby = 0.0;
                int nearbyGridsFound = 0;
                for (int rR = -1 * radius; rR <= radius; rR++) {
                    for (int rC = -1 * radius; rC <= radius; rC++) {
                        if (Math.abs(rR) + Math.abs(rC) <= radius) {
                            int nearbyR = r + rR;
                            int nearbyC = c + rC;
                            if (nearbyR >= 0 && nearbyC >= 0 && nearbyR < lstPresenceValues.size() && nearbyC < lstPresenceRow.size()) {
                                nearby = nearby + lstPresenceValues.get(nearbyR).get(nearbyC);
                                nearbyGridsFound++;
                            }
                        }
                    }
                }
                double nearbyWeight = nearby / (double) nearbyGridsFound;
                if (maxNearby < nearbyWeight) {
                    maxNearby = nearbyWeight;
                }
                lstNearbyRow.add(nearbyWeight);
            }
            lstNearbyValues.add(lstNearbyRow);
        }
        // Write the dataset file for nearby
        writeDataset(lstNearbyValues, file.getParent().resolve(filename.substring(0, filename.length() - 4) + "_nearby.idi"));
        // Read all baseline data
        List<List<Double>> lstBaselineValues = readDatasetFile(Paths.get(baselineFile));
        // Create the absence map
// TODO: It would be nice to also find a way to take the species count of the baseline file into account here...
        List<List<Double>> lstAbsenceValues = new ArrayList<>(lstBaselineValues.size());
        for (int r = 0; r < lstBaselineValues.size(); r++) {
            List<Double> lstBaselineRow = lstBaselineValues.get(r);
            List<Double> lstPresenceRow = lstPresenceValues.get(r);
            List<Double> lstAbsenceRow = new ArrayList<>(lstBaselineRow.size());
            lstAbsenceValues.add(lstAbsenceRow);
            for (int c = 0; c < lstBaselineRow.size(); c++) {
                double baselineValue = lstBaselineRow.get(c);
                double presenceValue = lstPresenceRow.get(c);
                double nearbyValue = lstNearbyValues.get(r).get(c) / maxNearby;
                double absenceValue = 0.0;
                if (baselineValue >= 0.7) {
                    if (presenceValue == 0.0 && nearbyValue < 0.3) {
                        absenceValue = 1.0 - (nearbyValue * 2.0);
                    }
                }
                lstAbsenceRow.add(absenceValue);
            }
        }
        // Write the dataset file for absence
        writeDataset(lstAbsenceValues, file.getParent().resolve(filename.substring(0, filename.length() - 4) + "_absence.idi"));
    }

    private void writeDataset(List<List<Double>> lstGridValues, Path file) throws IOException {
        Logger.getLogger(DataGeneratorAppForINat.class.getName()).log(Level.INFO, "Writing File: {0}", file.toString());
        if (!chkReplaceFiles.isSelected() && Files.exists(file)) {
            Logger.getLogger(DataGeneratorAppForINat.class.getName()).log(Level.INFO, "... The file will be skipped (not overwritten).");
            return;
        }
        // Get the max count
        double maxCount = 0.0;
        for (List<Double> lstPresenceRow : lstGridValues) {
            for (double value : lstPresenceRow) {
                if (value > maxCount) {
                    maxCount = value;
                }
            }
        }
        // Write the file
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(file.toFile()))) {
            for (List<Double> lstRowValues : lstGridValues) {
                for (double value : lstRowValues) {
                    writer.write(Double.toString(Math.round((value / maxCount) * 1000.0) / 1000.0));
                    writer.write(",");
                }
                writer.write(System.lineSeparator());
            }
            // Flushing and closing just to be paranoid (should be handled by the try-with-resources statement already)
            writer.flush();
            writer.close();
        }
    }
    
    private List<List<Double>> readDatasetFile(Path file) throws NumberFormatException, IOException {
        List<List<Double>> lstAllRowValues = new ArrayList<>();
        try (BufferedReader reader = new BufferedReader(new FileReader(file.toFile()))) {
            final String SEPARATOR_CHAR = ",";
            String line = null;
            while ((line = reader.readLine()) != null) {
                if (!line.trim().isEmpty()) {
                    String[] dataRow = line.split(SEPARATOR_CHAR);
                    List<Double> lstSingleRow = new ArrayList<>(dataRow.length);
                    for (String data : dataRow) {
                        lstSingleRow.add(Double.parseDouble(data));
                    }
                    lstAllRowValues.add(lstSingleRow);
                }
            }
            // Closing just to be paranoid (should be handled by the try-with-resources statement already)
            reader.close();
        }
        return lstAllRowValues;
    }

    private String buildGridKey(double lat, double lon) {
        return lat + "_" + lon;
    }
    
    private void writeDataset(Map<String, MapCounter> mapGridCounts, Path file) throws IOException {
        Logger.getLogger(DataGeneratorAppForINat.class.getName()).log(Level.INFO, "Writing File: {0}", file.toString());
        if (!chkReplaceFiles.isSelected() && Files.exists(file)) {
            Logger.getLogger(DataGeneratorAppForINat.class.getName()).log(Level.INFO, "... The file will be skipped (not overwritten).");
            return;
        }
        final double GRID_SIZE = (double) spnGridSize.getValue();
        // Adjust all the GPS values to make sure they are positive numbers, then it is simpler to do the comparisons
        // Latitude will be processed top to bottom
        final double LAT_END = Math.min(
                convertToGrid((double) spnLatTL.getValue(), GRID_SIZE) + 1000, 
                convertToGrid((double) spnLatBR.getValue(), GRID_SIZE) + 1000);
        double lat = Math.max(
                convertToGrid((double) spnLatTL.getValue(), GRID_SIZE) + 1000, 
                convertToGrid((double) spnLatBR.getValue(), GRID_SIZE) + 1000);
        // Longitude will be processed left to right
        final double LON_START = Math.min(
                convertToGrid((double) spnLonTL.getValue(), GRID_SIZE) + 1000, 
                convertToGrid((double) spnLonBR.getValue(), GRID_SIZE) + 1000);
        final double LON_END = Math.max(
                convertToGrid((double) spnLonTL.getValue(), GRID_SIZE) + 1000, 
                convertToGrid((double) spnLonBR.getValue(), GRID_SIZE) + 1000);
        double lon = Math.min(
                convertToGrid((double) spnLonTL.getValue(), GRID_SIZE) + 1000, 
                convertToGrid((double) spnLonBR.getValue(), GRID_SIZE) + 1000);
        // Get the max count
        double maxCount = 0.0;
        for (MapCounter counter : mapGridCounts.values()) {
            if (counter.count > maxCount) {
                maxCount = counter.count;
            }
        }
        final double MAX_COUNT_LOG = Math.log(maxCount);
        // Write the file
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(file.toFile()))) {
            while (lat > LAT_END) {
                while (lon < LON_END) {
                    String key = buildGridKey(lat - 1000, lon - 1000);
                    MapCounter counter = mapGridCounts.get(key);
                    if (counter == null) {
                        writer.write("0.0");
                    }
                    else {
                        double weight = Math.log(counter.count) / MAX_COUNT_LOG;
                        writer.write(Double.toString(Math.round(weight * 1000.0) / 1000.0));
                    }
                    // Move to the next column
                    writer.write(",");
                    lon = lon + GRID_SIZE; // left to right
                }
                // Move the the next row
                writer.write(System.lineSeparator());
                lon = LON_START;
                lat = lat - GRID_SIZE; // top to bottom
            }
            // Flushing and closing just to be paranoid (should be handled by the try-with-resources statement already)
            writer.flush();
            writer.close();
        }
    }
    
    private double convertToGrid(String value, double gridSize) {
        return convertToGrid(Double.parseDouble(value), gridSize);
    }
    
    private double convertToGrid(double value, double gridSize) {
        double temp = ((int) (Math.abs(value) / gridSize)) * gridSize;
        if (value < 0) {
            temp = -1 * temp;
        }
        return Math.round(temp * 1000.0) / 1000.0;
    }
    
    private final class MapCounter {
        public int count = 0;
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnBaselineFileBrowse;
    private javax.swing.JButton btnDataFolderBrowse;
    private javax.swing.JButton btnGenerateAbsenceDatasets;
    private javax.swing.JButton btnGeneratePresenceDatasets;
    private javax.swing.JCheckBox chkCSVHasHeader;
    private javax.swing.JCheckBox chkReplaceFiles;
    private javax.swing.JCheckBox chkUseINatFields;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel13;
    private javax.swing.JLabel jLabel15;
    private javax.swing.JLabel jLabel16;
    private javax.swing.JLabel jLabel17;
    private javax.swing.JLabel jLabel18;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JPanel jPanel5;
    private javax.swing.JPanel jPanel6;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JSpinner spnGridSize;
    private javax.swing.JSpinner spnLatBR;
    private javax.swing.JSpinner spnLatTL;
    private javax.swing.JSpinner spnLonBR;
    private javax.swing.JSpinner spnLonTL;
    private javax.swing.JSpinner spnNearbyRadius;
    private javax.swing.JTextField txtBaselineFilePath;
    private javax.swing.JTextField txtDataFolderPath;
    private javax.swing.JTextField txtLatName;
    private javax.swing.JTextField txtLonName;
    // End of variables declaration//GEN-END:variables
}
